<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tasks · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/base/parallel/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../../manual/getting-started/">入门</a></li><li><a class="toctext" href="../../manual/variables/">变量</a></li><li><a class="toctext" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="toctext" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="toctext" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="toctext" href="../../manual/strings/">字符串</a></li><li><a class="toctext" href="../../manual/functions/">函数</a></li><li><a class="toctext" href="../../manual/control-flow/">流程控制</a></li><li><a class="toctext" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="toctext" href="../../manual/types/">类型</a></li><li><a class="toctext" href="../../manual/methods/">方法</a></li><li><a class="toctext" href="../../manual/constructors/">构造函数</a></li><li><a class="toctext" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="toctext" href="../../manual/interfaces/">接口</a></li><li><a class="toctext" href="../../manual/modules/">模块</a></li><li><a class="toctext" href="../../manual/documentation/">文档</a></li><li><a class="toctext" href="../../manual/metaprogramming/">元编程</a></li><li><a class="toctext" href="../../manual/arrays/">多维数组</a></li><li><a class="toctext" href="../../manual/missing/">缺失值</a></li><li><a class="toctext" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="toctext" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="toctext" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="toctext" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="toctext" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="toctext" href="../../manual/environment-variables/">环境变量</a></li><li><a class="toctext" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="toctext" href="../../manual/code-loading/">代码加载</a></li><li><a class="toctext" href="../../manual/profile/">性能分析</a></li><li><a class="toctext" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="toctext" href="../../manual/performance-tips/">性能建议</a></li><li><a class="toctext" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="toctext" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="toctext" href="../../manual/faq/">常见问题</a></li><li><a class="toctext" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="toctext" href="../../manual/unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/">基本功能</a></li><li><a class="toctext" href="../collections/">集合和数据结构</a></li><li><a class="toctext" href="../math/">数学相关</a></li><li><a class="toctext" href="../numbers/">Numbers</a></li><li><a class="toctext" href="../strings/">字符串</a></li><li><a class="toctext" href="../arrays/">数组</a></li><li class="current"><a class="toctext" href>Tasks</a><ul class="internal"></ul></li><li><a class="toctext" href="../multi-threading/">多线程</a></li><li><a class="toctext" href="../constants/">常量</a></li><li><a class="toctext" href="../file/">文件系统</a></li><li><a class="toctext" href="../io-network/">I/O 与网络</a></li><li><a class="toctext" href="../punctuation/">运算符与记号</a></li><li><a class="toctext" href="../sort/">排序及相关函数</a></li><li><a class="toctext" href="../iterators/">迭代相关</a></li><li><a class="toctext" href="../c/">C 接口</a></li><li><a class="toctext" href="../libc/">C 标准库</a></li><li><a class="toctext" href="../stacktraces/">堆栈跟踪</a></li><li><a class="toctext" href="../simd-types/">SIMD 支持</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="toctext" href="../../stdlib/Distributed/">分布式计算</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">交互式组件</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">线性代数</a></li><li><a class="toctext" href="../../stdlib/Logging/">日志记录</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">性能分析</a></li><li><a class="toctext" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">随机数</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">序列化</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="toctext" href="../../stdlib/Sockets/">套接字</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="toctext" href="../../stdlib/Statistics/">统计</a></li><li><a class="toctext" href="../../stdlib/Test/">单元测试</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="toctext" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">子数组</a></li><li><a class="toctext" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">类型推断</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Base</li><li><a href>Tasks</a></li></ul><a class="edit-page" href="https://www.transifex.com/juliacn/base-zh_cn/translate/#zh_CN/parallelmd"><span class="fa"></span> 完善 Transifex 上的翻译</a></nav><hr/><div id="topbar"><span>Tasks</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tasks-1" href="#Tasks-1">Tasks</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Core.Task" href="#Core.Task"><code>Core.Task</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Task(func)</code></pre><p>Create a <code>Task</code> (i.e. coroutine) to execute the given function <code>func</code> (which must be callable with no arguments). The task exits when this function returns.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a() = sum(i for i in 1:1000);

julia&gt; b = Task(a);</code></pre><p>In this example, <code>b</code> is a runnable <code>Task</code> that hasn&#39;t started yet.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/docs/basedocs.jl#L982-L996">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.current_task" href="#Base.current_task"><code>Base.current_task</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">current_task()</code></pre><p>Get the currently running <a href="#Core.Task"><code>Task</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/task.jl#L88-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.istaskdone" href="#Base.istaskdone"><code>Base.istaskdone</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">istaskdone(t::Task) -&gt; Bool</code></pre><p>Determine whether a task has exited.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a2() = sum(i for i in 1:1000);

julia&gt; b = Task(a2);

julia&gt; istaskdone(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskdone(b)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/task.jl#L95-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.istaskstarted" href="#Base.istaskstarted"><code>Base.istaskstarted</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">istaskstarted(t::Task) -&gt; Bool</code></pre><p>Determine whether a task has started executing.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a3() = sum(i for i in 1:1000);

julia&gt; b = Task(a3);

julia&gt; istaskstarted(b)
false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/task.jl#L119-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.yield" href="#Base.yield"><code>Base.yield</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">yield()</code></pre><p>Switch to the scheduler to allow another scheduled task to run. A task that calls this function is still runnable, and will be restarted immediately if there are no other runnable tasks.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/event.jl#L150-L156">source</a><div><div><pre><code class="language-none">yield(t::Task, arg = nothing)</code></pre><p>A fast, unfair-scheduling version of <code>schedule(t, arg); yield()</code> which immediately yields to <code>t</code> before calling the scheduler.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/event.jl#L159-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.yieldto" href="#Base.yieldto"><code>Base.yieldto</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">yieldto(t::Task, arg = nothing)</code></pre><p>Switch to the given task. The first time a task is switched to, the task&#39;s function is called with no arguments. On subsequent switches, <code>arg</code> is returned from the task&#39;s last call to <code>yieldto</code>. This is a low-level call that only switches tasks, not considering states or scheduling in any way. Its use is discouraged.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/event.jl#L172-L179">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.task_local_storage-Tuple{Any}" href="#Base.task_local_storage-Tuple{Any}"><code>Base.task_local_storage</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">task_local_storage(key)</code></pre><p>Look up the value of a key in the current task&#39;s task-local storage.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/task.jl#L148-L152">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.task_local_storage-Tuple{Any,Any}" href="#Base.task_local_storage-Tuple{Any,Any}"><code>Base.task_local_storage</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">task_local_storage(key, value)</code></pre><p>Assign a value to a key in the current task&#39;s task-local storage.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/task.jl#L155-L159">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.task_local_storage-Tuple{Function,Any,Any}" href="#Base.task_local_storage-Tuple{Function,Any,Any}"><code>Base.task_local_storage</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">task_local_storage(body, key, value)</code></pre><p>Call the function <code>body</code> with a modified task-local storage, in which <code>value</code> is assigned to <code>key</code>; the previous value of <code>key</code>, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/task.jl#L162-L168">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Condition" href="#Base.Condition"><code>Base.Condition</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Condition()</code></pre><p>Create an edge-triggered event source that tasks can wait for. Tasks that call <a href="../../stdlib/Distributed/#Base.wait"><code>wait</code></a> on a <code>Condition</code> are suspended and queued. Tasks are woken up when <a href="#Base.notify"><code>notify</code></a> is later called on the <code>Condition</code>. Edge triggering means that only tasks waiting at the time <a href="#Base.notify"><code>notify</code></a> is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The <a href="#Base.Channel"><code>Channel</code></a> type does this, and so can be used for level-triggered events.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/event.jl#L5-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.notify" href="#Base.notify"><code>Base.notify</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">notify(condition, val=nothing; all=true, error=false)</code></pre><p>Wake up tasks waiting for a condition, passing them <code>val</code>. If <code>all</code> is <code>true</code> (the default), all waiting tasks are woken, otherwise only one is. If <code>error</code> is <code>true</code>, the passed value is raised as an exception in the woken tasks.</p><p>Return the count of tasks woken up. Return 0 if no tasks are waiting on <code>condition</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/event.jl#L53-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.schedule" href="#Base.schedule"><code>Base.schedule</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">schedule(t::Task, [val]; error=false)</code></pre><p>Add a <a href="#Core.Task"><code>Task</code></a> to the scheduler&#39;s queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as <a href="../../stdlib/Distributed/#Base.wait"><code>wait</code></a>.</p><p>If a second argument <code>val</code> is provided, it will be passed to the task (via the return value of <a href="#Base.yieldto"><code>yieldto</code></a>) when it runs again. If <code>error</code> is <code>true</code>, the value is raised as an exception in the woken task.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a5() = sum(i for i in 1:1000);

julia&gt; b = Task(a5);

julia&gt; istaskstarted(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskstarted(b)
true

julia&gt; istaskdone(b)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/event.jl#L97-L126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.@task" href="#Base.@task"><code>Base.@task</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@task</code></pre><p>Wrap an expression in a <a href="#Core.Task"><code>Task</code></a> without executing it, and return the <a href="#Core.Task"><code>Task</code></a>. This only creates a task, and does not run it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a1() = sum(i for i in 1:1000);

julia&gt; b = @task a1();

julia&gt; istaskstarted(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskdone(b)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/task.jl#L61-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sleep" href="#Base.sleep"><code>Base.sleep</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sleep(seconds)</code></pre><p>Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of <code>0.001</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/event.jl#L421-L426">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Channel" href="#Base.Channel"><code>Base.Channel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Channel{T}(sz::Int)</code></pre><p>Constructs a <code>Channel</code> with an internal buffer that can hold a maximum of <code>sz</code> objects of type <code>T</code>. <a href="#Base.put!-Tuple{Channel,Any}"><code>put!</code></a> calls on a full channel block until an object is removed with <a href="#Base.take!-Tuple{Channel}"><code>take!</code></a>.</p><p><code>Channel(0)</code> constructs an unbuffered channel. <code>put!</code> blocks until a matching <code>take!</code> is called. And vice-versa.</p><p>Other constructors:</p><ul><li><code>Channel(Inf)</code>: equivalent to <code>Channel{Any}(typemax(Int))</code></li><li><code>Channel(sz)</code>: equivalent to <code>Channel{Any}(sz)</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/channels.jl#L5-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.put!-Tuple{Channel,Any}" href="#Base.put!-Tuple{Channel,Any}"><code>Base.put!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">put!(c::Channel, v)</code></pre><p>Append an item <code>v</code> to the channel <code>c</code>. Blocks if the channel is full.</p><p>For unbuffered channels, blocks until a <a href="#Base.take!-Tuple{Channel}"><code>take!</code></a> is performed by a different task.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/channels.jl#L241-L248">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.take!-Tuple{Channel}" href="#Base.take!-Tuple{Channel}"><code>Base.take!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">take!(c::Channel)</code></pre><p>Remove and return a value from a <a href="#Base.Channel"><code>Channel</code></a>. Blocks until data is available.</p><p>For unbuffered channels, blocks until a <a href="#Base.put!-Tuple{Channel,Any}"><code>put!</code></a> is performed by a different task.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/channels.jl#L298-L305">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isready-Tuple{Channel}" href="#Base.isready-Tuple{Channel}"><code>Base.isready</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isready(c::Channel)</code></pre><p>Determine whether a <a href="#Base.Channel"><code>Channel</code></a> has a value stored to it. Returns immediately, does not block.</p><p>For unbuffered channels returns <code>true</code> if there are tasks waiting on a <a href="#Base.put!-Tuple{Channel,Any}"><code>put!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/channels.jl#L337-L345">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.fetch-Tuple{Channel}" href="#Base.fetch-Tuple{Channel}"><code>Base.fetch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">fetch(c::Channel)</code></pre><p>Wait for and get the first available item from the channel. Does not remove the item. <code>fetch</code> is unsupported on an unbuffered (0-size) channel.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/channels.jl#L284-L289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.close-Tuple{Channel}" href="#Base.close-Tuple{Channel}"><code>Base.close</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">close(c::Channel)</code></pre><p>Close a channel. An exception is thrown by:</p><ul><li><a href="#Base.put!-Tuple{Channel,Any}"><code>put!</code></a> on a closed channel.</li><li><a href="#Base.take!-Tuple{Channel}"><code>take!</code></a> and <a href="#Base.fetch-Tuple{Channel}"><code>fetch</code></a> on an empty, closed channel.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/channels.jl#L124-L131">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.bind-Tuple{Channel,Task}" href="#Base.bind-Tuple{Channel,Task}"><code>Base.bind</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bind(chnl::Channel, task::Task)</code></pre><p>Associate the lifetime of <code>chnl</code> with a task. <code>Channel</code> <code>chnl</code> is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on <code>chnl</code>.</p><p>The <code>chnl</code> object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed <code>Channel</code> objects.</p><p>When a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; c = Channel(0);

julia&gt; task = @async foreach(i-&gt;put!(c, i), 1:4);

julia&gt; bind(c,task);

julia&gt; for i in c
           @show i
       end;
i = 1
i = 2
i = 3
i = 4

julia&gt; isopen(c)
false</code></pre><pre><code class="language-julia-repl">julia&gt; c = Channel(0);

julia&gt; task = @async (put!(c,1);error(&quot;foo&quot;));

julia&gt; bind(c,task);

julia&gt; take!(c)
1

julia&gt; put!(c,1);
ERROR: foo
Stacktrace:
[...]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/channels.jl#L140-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.asyncmap" href="#Base.asyncmap"><code>Base.asyncmap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">asyncmap(f, c...; ntasks=0, batch_size=nothing)</code></pre><p>Uses multiple concurrent tasks to map <code>f</code> over a collection (or multiple equal length collections). For multiple collection arguments, <code>f</code> is applied elementwise.</p><p><code>ntasks</code> specifies the number of tasks to run concurrently. Depending on the length of the collections, if <code>ntasks</code> is unspecified, up to 100 tasks will be used for concurrent mapping.</p><p><code>ntasks</code> can also be specified as a zero-arg function. In this case, the number of tasks to run in parallel is checked before processing every element and a new task started if the value of <code>ntasks_func</code> is less than the current number of tasks.</p><p>If <code>batch_size</code> is specified, the collection is processed in batch mode. <code>f</code> must then be a function that must accept a <code>Vector</code> of argument tuples and must return a vector of results. The input vector will have a length of <code>batch_size</code> or less.</p><p>The following examples highlight execution in different tasks by returning the <code>objectid</code> of the tasks in which the mapping function is executed.</p><p>First, with <code>ntasks</code> undefined, each element is processed in a different task.</p><pre><code class="language-none">julia&gt; tskoid() = objectid(current_task());

julia&gt; asyncmap(x-&gt;tskoid(), 1:5)
5-element Array{UInt64,1}:
 0x6e15e66c75c75853
 0x440f8819a1baa682
 0x9fb3eeadd0c83985
 0xebd3e35fe90d4050
 0x29efc93edce2b961

julia&gt; length(unique(asyncmap(x-&gt;tskoid(), 1:5)))
5</code></pre><p>With <code>ntasks=2</code> all elements are processed in 2 tasks.</p><pre><code class="language-none">julia&gt; asyncmap(x-&gt;tskoid(), 1:5; ntasks=2)
5-element Array{UInt64,1}:
 0x027ab1680df7ae94
 0xa23d2f80cd7cf157
 0x027ab1680df7ae94
 0xa23d2f80cd7cf157
 0x027ab1680df7ae94

julia&gt; length(unique(asyncmap(x-&gt;tskoid(), 1:5; ntasks=2)))
2</code></pre><p>With <code>batch_size</code> defined, the mapping function needs to be changed to accept an array of argument tuples and return an array of results. <code>map</code> is used in the modified mapping function to achieve this.</p><pre><code class="language-none">julia&gt; batch_func(input) = map(x-&gt;string(&quot;args_tuple: &quot;, x, &quot;, element_val: &quot;, x[1], &quot;, task: &quot;, tskoid()), input)
batch_func (generic function with 1 method)

julia&gt; asyncmap(batch_func, 1:5; ntasks=2, batch_size=2)
5-element Array{String,1}:
 &quot;args_tuple: (1,), element_val: 1, task: 9118321258196414413&quot;
 &quot;args_tuple: (2,), element_val: 2, task: 4904288162898683522&quot;
 &quot;args_tuple: (3,), element_val: 3, task: 9118321258196414413&quot;
 &quot;args_tuple: (4,), element_val: 4, task: 4904288162898683522&quot;
 &quot;args_tuple: (5,), element_val: 5, task: 9118321258196414413&quot;</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Currently, all tasks in Julia are executed in a single OS thread co-operatively. Consequently, <code>asyncmap</code> is beneficial only when the mapping function involves any I/O - disk, network, remote worker invocation, etc.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/asyncmap.jl#L5-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.asyncmap!" href="#Base.asyncmap!"><code>Base.asyncmap!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">asyncmap!(f, results, c...; ntasks=0, batch_size=nothing)</code></pre><p>Like <a href="#Base.asyncmap"><code>asyncmap</code></a>, but stores output in <code>results</code> rather than returning a collection.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/099e826241fca365a120df9bac9a9fede6e7bae4/base/asyncmap.jl#L412-L417">source</a></section><footer><hr/><a class="previous" href="../arrays/"><span class="direction">上一篇</span><span class="title">数组</span></a><a class="next" href="../multi-threading/"><span class="direction">下一篇</span><span class="title">多线程</span></a></footer></article></body></html>
