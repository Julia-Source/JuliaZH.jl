<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Static analyzer annotations for GC correctness in C code · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/devdocs/gc-sa/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../../manual/getting-started/">入门</a></li><li><a class="toctext" href="../../manual/variables/">变量</a></li><li><a class="toctext" href="../../manual/integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="toctext" href="../../manual/mathematical-operations/">数学运算和初等函数</a></li><li><a class="toctext" href="../../manual/complex-and-rational-numbers/">复数和有理数</a></li><li><a class="toctext" href="../../manual/strings/">字符串</a></li><li><a class="toctext" href="../../manual/functions/">函数</a></li><li><a class="toctext" href="../../manual/control-flow/">流程控制</a></li><li><a class="toctext" href="../../manual/variables-and-scoping/">变量作用域</a></li><li><a class="toctext" href="../../manual/types/">类型</a></li><li><a class="toctext" href="../../manual/methods/">方法</a></li><li><a class="toctext" href="../../manual/constructors/">构造函数</a></li><li><a class="toctext" href="../../manual/conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="toctext" href="../../manual/interfaces/">接口</a></li><li><a class="toctext" href="../../manual/modules/">模块</a></li><li><a class="toctext" href="../../manual/documentation/">文档</a></li><li><a class="toctext" href="../../manual/metaprogramming/">元编程</a></li><li><a class="toctext" href="../../manual/arrays/">多维数组</a></li><li><a class="toctext" href="../../manual/missing/">缺失值</a></li><li><a class="toctext" href="../../manual/networking-and-streams/">网络和流</a></li><li><a class="toctext" href="../../manual/parallel-computing/">并行计算</a></li><li><a class="toctext" href="../../manual/running-external-programs/">运行外部程序</a></li><li><a class="toctext" href="../../manual/calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="toctext" href="../../manual/handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="toctext" href="../../manual/environment-variables/">环境变量</a></li><li><a class="toctext" href="../../manual/embedding/">嵌入 Julia</a></li><li><a class="toctext" href="../../manual/code-loading/">代码加载</a></li><li><a class="toctext" href="../../manual/profile/">性能分析</a></li><li><a class="toctext" href="../../manual/stacktraces/">栈跟踪</a></li><li><a class="toctext" href="../../manual/performance-tips/">性能建议</a></li><li><a class="toctext" href="../../manual/workflow-tips/">工作流程建议</a></li><li><a class="toctext" href="../../manual/style-guide/">代码风格指南</a></li><li><a class="toctext" href="../../manual/faq/">常见问题</a></li><li><a class="toctext" href="../../manual/noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="toctext" href="../../manual/unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">基本功能</a></li><li><a class="toctext" href="../../base/collections/">集合和数据结构</a></li><li><a class="toctext" href="../../base/math/">数学相关</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">字符串</a></li><li><a class="toctext" href="../../base/arrays/">数组</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">多线程</a></li><li><a class="toctext" href="../../base/constants/">常量</a></li><li><a class="toctext" href="../../base/file/">文件系统</a></li><li><a class="toctext" href="../../base/io-network/">I/O 与网络</a></li><li><a class="toctext" href="../../base/punctuation/">运算符与记号</a></li><li><a class="toctext" href="../../base/sort/">排序及相关函数</a></li><li><a class="toctext" href="../../base/iterators/">迭代相关</a></li><li><a class="toctext" href="../../base/c/">C 接口</a></li><li><a class="toctext" href="../../base/libc/">C 标准库</a></li><li><a class="toctext" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="toctext" href="../../stdlib/Distributed/">分布式计算</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">交互式组件</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">线性代数</a></li><li><a class="toctext" href="../../stdlib/Logging/">日志记录</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">性能分析</a></li><li><a class="toctext" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">随机数</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">序列化</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="toctext" href="../../stdlib/Sockets/">套接字</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="toctext" href="../../stdlib/Statistics/">统计</a></li><li><a class="toctext" href="../../stdlib/Test/">单元测试</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../reflection/">反射 与 自我检查</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../init/">Julia 运行时的初始化</a></li><li><a class="toctext" href="../ast/">Julia 的 AST</a></li><li><a class="toctext" href="../types/">More about types</a></li><li><a class="toctext" href="../object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../eval/">Julia 代码的 eval</a></li><li><a class="toctext" href="../callconv/">Calling Conventions</a></li><li><a class="toctext" href="../compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../functions/">Julia 函数</a></li><li><a class="toctext" href="../cartesian/">笛卡尔</a></li><li><a class="toctext" href="../meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../subarrays/">子数组</a></li><li><a class="toctext" href="../isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../sysimg/">System Image Building</a></li><li><a class="toctext" href="../llvm/">Working with LLVM</a></li><li><a class="toctext" href="../stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../boundscheck/">边界检查</a></li><li><a class="toctext" href="../locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../require/">Module loading</a></li><li><a class="toctext" href="../inference/">类型推导</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="toctext" href="../debuggingtips/">gdb 调试提示</a></li><li><a class="toctext" href="../valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Static analyzer annotations for GC correctness in C code</a></li></ul><a class="edit-page" href="https://www.transifex.com/juliacn/devdocs-zh_cn/translate/#zh_CN/gc-samd"><span class="fa"></span> 完善 Transifex 上的翻译</a></nav><hr/><div id="topbar"><span>Static analyzer annotations for GC correctness in C code</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Static-analyzer-annotations-for-GC-correctness-in-C-code-1" href="#Static-analyzer-annotations-for-GC-correctness-in-C-code-1">Static analyzer annotations for GC correctness in C code</a></h1><h2><a class="nav-anchor" id="General-Overview-1" href="#General-Overview-1">General Overview</a></h2><p>Since Julia&#39;s GC is precise, it needs to maintain correct rooting information for any value that may be referenced at any time GC may occur. These places are known as <code>safepoints</code> and in the function local context, we extend this designation to any function call that may recursively end up at a safepoint.</p><p>In generated code, this is taken care of automatically by the GC root placement pass (see the chapter on GC rooting in the LLVM codegen devdocs). However, in C code, we need to inform the runtime of any GC roots manually. This is done using the following macros:</p><pre><code class="language-none">// The value assigned to any slot passed as an argument to these
// is rooted for the duration of this GC frame.
JL_GC_PUSH{1,...,6}(args...)
// The values assigned into the size `n` array `rts` are rooted
// for the duration of this GC frame.
JL_GC_PUSHARGS(rts, n)
// Pop a GC frame
JL_GC_POP</code></pre><p>If these macros are not used where they need to be, or they are used incorrectly, the result is silent memory corruption. As such it is very important that they are placed correctly in all applicable code.</p><p>As such, we employ static analysis (and in particular the clang static analyzer) to help ensure that these macros are used correctly. The remainder of this document gives an overview of this static analysis and describes the support needed in the julia code base to make things work.</p><h2><a class="nav-anchor" id="GC-Invariants-1" href="#GC-Invariants-1">GC Invariants</a></h2><p>There is two simple invariants correctness:</p><ul><li>All GC<em>PUSH calls need to be followed by an appropriate GC</em>POP (in practice we enforce this at the function level)</li><li>If a value was previously not rooted at any safepoint, it may no longer be referenced afterwards</li></ul><p>Of course the devil is in the details here. In particular to satisfy the second of the above conditions, we need to know:</p><ul><li>Which calls are safepoints and which are not</li><li>Which values are rooted at any given safepoint and which are not</li><li>When is a value referenced</li></ul><p>For the second point in particular, we need to know which memory locations will be considered rooting at runtime (i.e. values assigned to such locations are rooted). This includes locations explicitly designated as such by passing them to one of the <code>GC_PUSH</code> macros, globally rooted locations and values, as well as any location recursively reachable from one of those locations.</p><h2><a class="nav-anchor" id="Static-Analysis-Algorithm-1" href="#Static-Analysis-Algorithm-1">Static Analysis Algorithm</a></h2><p>The idea itself is very simple, although the implementation is quite a bit more complicated (mainly due to a large number of special cases and intricacies of C and C++). In essence, we keep track of all locations that are rooting, all values that are rootable and any expression (assignments, allocations, etc) affect the rootedness of any rootable values. Then, at any safepoint, we perform a &quot;symbolic GC&quot; and poison any values that are not rooted at said location. If these values are later referenced, we emit an error.</p><p>The clang static analyzer works by constructing a graph of states and exploring this graph for sources of errors. Several nodes in this graph are generated by the analyzer itself (e.g. for control flow), but the definitions above augment this graph with our own state.</p><p>The static analyzer is interprocedural and can analyze control flow across function boundaries. However, the static analyzer is not fully recursive and makes heuristic decisions about which calls to explore (additionally some calls are cross-translation unit and invisible to the analyzer). In our case, our definition of correctness requires total information. As such, we need to annotate the prototypes of all function calls with whatever information the analysis required, even if that information would otherwise be available by interprocedural static analysis.</p><p>Luckily however, we can still use this interprocedural analysis to ensure that the annotations we place on a given function are indeed correct given the implementation of said function.</p><h2><a class="nav-anchor" id="The-analyzer-annotations-1" href="#The-analyzer-annotations-1">The analyzer annotations</a></h2><p>These annotations are found in src/support/analyzer_annotations.h. The are only active when the analyzer is being used and expand either to nothing (for prototype annotations) or to no-ops (for function like annotations).</p><h3><a class="nav-anchor" id="JL_NOTSAFEPOINT-1" href="#JL_NOTSAFEPOINT-1">JL_NOTSAFEPOINT</a></h3><p>This is perhaps the most common annotation, and should be placed on any function that is known not to possibly lead to reaching a GC safepoint. In general, it is only safe for such a function to perform arithmetic, memory accesses and calls to functions either annotated JL_NOTSAFEPOINT or otherwise known not to be safepoints (e.g. function in the C standard library, which are hardcoded as such in the analyzer)</p><p>It is valid to keep values unrooted across calls to any function annotated with this attribute:</p><p>Usage Example:</p><pre><code class="language-c">void jl_get_one() JL_NOTSAFEPOINT {
  return 1;
}

jl_value_t *example() {
  jl_value_t *val = jl_alloc_whatever();
  // This is valid, even though `val` is unrooted, because
  // jl_get_one is not a safepoint
  jl_get_one();
  return val;
}</code></pre><h3><a class="nav-anchor" id="JL*MAYBE*UNROOTED/JL*ROOTS*TEMPORARILY-1" href="#JL*MAYBE*UNROOTED/JL*ROOTS*TEMPORARILY-1">JL<em>MAYBE</em>UNROOTED/JL<em>ROOTS</em>TEMPORARILY</a></h3><p>When <code>JL_MAYBE_UNROOTED</code> is annotated as an argument on a function, indicates that said argument may be passed, even if it is not rooted. In the ordinary course of events, the julia ABI guarantees that callers root values before passing them to callees. However, some functions do not follow this ABI and allow values to be passed to them even though they are not rooted. Note however, that this does not automatically imply that said argument will be preserved. The <code>ROOTS_TEMPORARILY</code> annotation provides the stronger guarantee that, not only may the value be unrooted when passed, it will also be preserved across any internal safepoints by the callee.</p><p>Note that JL<em>NOTSAFEPOINT essentially implies JL</em>MAYBE<em>UNROOTED/JL</em>ROOTS_TEMPORARILY, because the rootedness of an argument is irrelevant if the function contains no safepoints.</p><p>One additional point to note is that these annotations apply on both the caller and the callee side. On the caller side, they lift rootedness restrictions that are normally required for julia ABI functions. On the callee side, they have the reverse effect of preventing these arguments from being considered implicitly rooted.</p><p>If either of these annotations is applied to the function as a whole, it applies to all arguments of the function. This should generally only be necessary for varargs functions.</p><p>Usage example:</p><pre><code class="language-c">JL_DLLEXPORT void JL_NORETURN jl_throw(jl_value_t *e JL_MAYBE_UNROOTED);
jl_value_t *jl_alloc_error();

void example() {
  // The return value of the allocation is unrooted. This would normally
  // be an error, but is allowed because of the above annotation.
  jl_throw(jl_alloc_error());
}</code></pre><h3><a class="nav-anchor" id="JL*PROPAGATES*ROOT-1" href="#JL*PROPAGATES*ROOT-1">JL<em>PROPAGATES</em>ROOT</a></h3><p>This annotation is commonly found on accessor functions that return one rootable object stored within another. When annotated on a function argument, it tells the analyzer that the root for that argument also applies to the value returned by the function.</p><p>Usage Example:</p><pre><code class="language-c">jl_value_t *jl_svecref(jl_svec_t *t JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;

size_t example(jl_svec_t *svec) {
  jl_value_t *val = jl_svecref(svec, 1)
  // This is valid, because, as annotated by the PROPAGATES_ROOT annotation,
  // jl_svecref propagates the rooted-ness from `svec` to `val`
  jl_gc_safepoint();
  return jl_unbox_long(val);
}</code></pre><h3><a class="nav-anchor" id="JL*ROOTING*ARGUMENT/JL*ROOTED*ARGUMENT-1" href="#JL*ROOTING*ARGUMENT/JL*ROOTED*ARGUMENT-1">JL<em>ROOTING</em>ARGUMENT/JL<em>ROOTED</em>ARGUMENT</a></h3><p>This is essentially the assignment counterpart to <code>JL_PROPAGATES_ROOT</code>. When assigning a value to a field of another value that is already rooted, the assigned value will inherit the root of the value it is assigned into.</p><p>Usage Example:</p><pre><code class="language-c">void jl_svecset(void *t JL_ROOTING_ARGUMENT, size_t i, void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT


size_t example(jl_svec_t *svec) {
  jl_value_t *val = jl_box_long(10000);
  jl_svecset(svec, val);
  // This is valid, because the annotations imply that the
  // jl_svecset propagates the rooted-ness from `svec` to `val`
  jl_gc_safepoint();
  return jl_unbox_long(val);
}</code></pre><h3><a class="nav-anchor" id="JL*GC*DISABLED-1" href="#JL*GC*DISABLED-1">JL<em>GC</em>DISABLED</a></h3><p>This annotation implies that this function is only called with the GC runtime-disabled. Functions of this kind are most often encountered during startup and in the GC code itself. Note that this annotation is checked against the runtime enable/disable calls, so clang will know if you lie. This is not a good way to disable processing of a given function if the GC is not actually disabled (use ifdef <strong>clang_analyzer</strong> for that if you must).</p><p>Usage example:</p><pre><code class="language-c">void jl_do_magic() JL_GC_DISABLED {
  // Wildly allocate here with no regard for roots
}

void example() {
  int en = jl_gc_enable(0);
  jl_do_magic();
  jl_gc_enable(en);
}</code></pre><h3><a class="nav-anchor" id="JL*REQUIRE*ROOTED_SLOT-1" href="#JL*REQUIRE*ROOTED_SLOT-1">JL<em>REQUIRE</em>ROOTED_SLOT</a></h3><p>This annotation requires the caller to pass in a slot that is rooted (i.e. values assigned to this slot will be rooted).</p><p>Usage example:</p><pre><code class="language-c">void jl_do_processing(jl_value_t **slot JL_REQUIRE_ROOTED_SLOT) {
  *slot = jl_box_long(1);
  // Ok, only, because the slot was annotated as rooting
  jl_gc_safepoint();
}

void example() {
  jl_value_t *slot = NULL;
  JL_GC_PUSH1(&amp;slot);
  jl_do_processing(&amp;slot);
  JL_GC_POP();
}</code></pre><h3><a class="nav-anchor" id="JL*GLOBALLY*ROOTED-1" href="#JL*GLOBALLY*ROOTED-1">JL<em>GLOBALLY</em>ROOTED</a></h3><p>This annotation implies that a given value is always globally rooted. It can be applied to global variable declarations, in which case it will apply to the value of those variables (or values if the declaration if for an array), or to functions, in which case it will apply to the return value of such functions (e.g. for functions that always return some private, globally rooted value).</p><p>Usage example:</p><pre><code class="language-none">extern JL_DLLEXPORT jl_datatype_t *jl_any_type JL_GLOBALLY_ROOTED;
jl_ast_context_t *jl_ast_ctx(fl_context_t *fl) JL_GLOBALLY_ROOTED;</code></pre><h3><a class="nav-anchor" id="JL*ALWAYS*LEAFTYPE-1" href="#JL*ALWAYS*LEAFTYPE-1">JL<em>ALWAYS</em>LEAFTYPE</a></h3><p>This annotations is essentially equivalent to JL<em>GLOBALLY</em>ROOTED, except that is should only be used if those values are globally rooted by virtue of being a leaftype. The rooting of leaftypes is a bit complicated, and we can generally assume that leaftypes are rooted where they are used, but we may refine this property in the future, so the separate annotation helps split out the reason for being globally rooted.</p><p>The analyzer also automatically detects checks for leaftype-ness and will not complain about missing GC roots on these paths.</p><pre><code class="language-none">JL_DLLEXPORT jl_value_t *jl_apply_array_type(jl_value_t *type, size_t dim) JL_ALWAYS_LEAFTYPE;</code></pre><h3><a class="nav-anchor" id="JL*GC*PROMISE_ROOTED-1" href="#JL*GC*PROMISE_ROOTED-1">JL<em>GC</em>PROMISE_ROOTED</a></h3><p>This is a function-like annotation. Any value passed to this annotation will be considered rooted for the scope of the current function. It is designed as an escape hatch for analyzer inadequacy or complicated situations. However, it should be used sparingly, in favor of improving the analyzer itself.</p><pre><code class="language-none">void example() {
  jl_value_t *val = jl_alloc_something();
  if (some_condition) {
    // We happen to know for complicated external reasons
    // that val is rooted under these conditions
    JL_GC_PROMISE_ROOTED(val);
  }
}</code></pre><h2><a class="nav-anchor" id="Completeness-of-analysis-1" href="#Completeness-of-analysis-1">Completeness of analysis</a></h2><p>The analyzer only looks at local information. In particular, e.g. in the <code>PROPAGATES_ROOT</code> case above, it assumes that such memory is only modified in ways it can see, not in any called functions (unless it happens to decide to consider them in its analysis) and not in any concurrently running threads. As such, it may miss a few problematic cases, though in practice such concurrent modification is fairly rare. Improving the analyzer to handle more such cases may be an interesting topic for future work.</p><footer><hr/></footer></article></body></html>
