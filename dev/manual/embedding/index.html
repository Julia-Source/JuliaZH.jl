<!DOCTYPE html>
<html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>嵌入 Julia · Julia中文文档</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-9', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://juliacn.github.io/JuliaZH.jl/latest/manual/embedding/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="Julia中文文档 logo"/></a><h1>Julia中文文档</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">主页</a></li><li><span class="toctext">手册</span><ul><li><a class="toctext" href="../getting-started/">入门</a></li><li><a class="toctext" href="../variables/">变量</a></li><li><a class="toctext" href="../integers-and-floating-point-numbers/">整数和浮点数</a></li><li><a class="toctext" href="../mathematical-operations/">数学运算和初等函数</a></li><li><a class="toctext" href="../complex-and-rational-numbers/">复数和有理数</a></li><li><a class="toctext" href="../strings/">字符串</a></li><li><a class="toctext" href="../functions/">函数</a></li><li><a class="toctext" href="../control-flow/">流程控制</a></li><li><a class="toctext" href="../variables-and-scoping/">变量作用域</a></li><li><a class="toctext" href="../types/">类型</a></li><li><a class="toctext" href="../methods/">方法</a></li><li><a class="toctext" href="../constructors/">构造函数</a></li><li><a class="toctext" href="../conversion-and-promotion/">类型转换和类型提升</a></li><li><a class="toctext" href="../interfaces/">接口</a></li><li><a class="toctext" href="../modules/">模块</a></li><li><a class="toctext" href="../documentation/">文档</a></li><li><a class="toctext" href="../metaprogramming/">元编程</a></li><li><a class="toctext" href="../arrays/">多维数组</a></li><li><a class="toctext" href="../missing/">缺失值</a></li><li><a class="toctext" href="../networking-and-streams/">网络和流</a></li><li><a class="toctext" href="../parallel-computing/">并行计算</a></li><li><a class="toctext" href="../running-external-programs/">运行外部程序</a></li><li><a class="toctext" href="../calling-c-and-fortran-code/">调用 C 和 Fortran 代码</a></li><li><a class="toctext" href="../handling-operating-system-variation/">处理操作系统差异</a></li><li><a class="toctext" href="../environment-variables/">环境变量</a></li><li class="current"><a class="toctext" href>嵌入 Julia</a><ul class="internal"><li><a class="toctext" href="#高级别嵌入-1">高级别嵌入</a></li><li><a class="toctext" href="#High-Level-Embedding-on-Windows-with-Visual-Studio-1">High-Level Embedding on Windows with Visual Studio</a></li><li><a class="toctext" href="#转换类型-1">转换类型</a></li><li><a class="toctext" href="#调用-Julia-函数-1">调用 Julia 函数</a></li><li><a class="toctext" href="#内存管理-1">内存管理</a></li><li><a class="toctext" href="#使用数组-1">使用数组</a></li><li><a class="toctext" href="#异常-1">异常</a></li></ul></li><li><a class="toctext" href="../code-loading/">代码加载</a></li><li><a class="toctext" href="../profile/">性能分析</a></li><li><a class="toctext" href="../stacktraces/">栈跟踪</a></li><li><a class="toctext" href="../performance-tips/">性能建议</a></li><li><a class="toctext" href="../workflow-tips/">工作流程建议</a></li><li><a class="toctext" href="../style-guide/">代码风格指南</a></li><li><a class="toctext" href="../faq/">常见问题</a></li><li><a class="toctext" href="../noteworthy-differences/">与其他语言的显著差异</a></li><li><a class="toctext" href="../unicode-input/">Unicode 输入表</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../../base/base/">基本功能</a></li><li><a class="toctext" href="../../base/collections/">集合和数据结构</a></li><li><a class="toctext" href="../../base/math/">数学相关</a></li><li><a class="toctext" href="../../base/numbers/">Numbers</a></li><li><a class="toctext" href="../../base/strings/">字符串</a></li><li><a class="toctext" href="../../base/arrays/">数组</a></li><li><a class="toctext" href="../../base/parallel/">Tasks</a></li><li><a class="toctext" href="../../base/multi-threading/">多线程</a></li><li><a class="toctext" href="../../base/constants/">常量</a></li><li><a class="toctext" href="../../base/file/">文件系统</a></li><li><a class="toctext" href="../../base/io-network/">I/O 与网络</a></li><li><a class="toctext" href="../../base/punctuation/">运算符与记号</a></li><li><a class="toctext" href="../../base/sort/">排序及相关函数</a></li><li><a class="toctext" href="../../base/iterators/">迭代相关</a></li><li><a class="toctext" href="../../base/c/">C 接口</a></li><li><a class="toctext" href="../../base/libc/">C 标准库</a></li><li><a class="toctext" href="../../base/stacktraces/">堆栈跟踪</a></li><li><a class="toctext" href="../../base/simd-types/">SIMD 支持</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../../stdlib/DelimitedFiles/">分隔符文件</a></li><li><a class="toctext" href="../../stdlib/Distributed/">分布式计算</a></li><li><a class="toctext" href="../../stdlib/FileWatching/">文件相关事件</a></li><li><a class="toctext" href="../../stdlib/InteractiveUtils/">交互式组件</a></li><li><a class="toctext" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../../stdlib/Libdl/">动态链接器</a></li><li><a class="toctext" href="../../stdlib/LinearAlgebra/">线性代数</a></li><li><a class="toctext" href="../../stdlib/Logging/">日志记录</a></li><li><a class="toctext" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../../stdlib/Mmap/">内存映射 I/O</a></li><li><a class="toctext" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../../stdlib/Profile/">性能分析</a></li><li><a class="toctext" href="../../stdlib/REPL/">Julia REPL</a></li><li><a class="toctext" href="../../stdlib/Random/">随机数</a></li><li><a class="toctext" href="../../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../../stdlib/Serialization/">序列化</a></li><li><a class="toctext" href="../../stdlib/SharedArrays/">共享数组</a></li><li><a class="toctext" href="../../stdlib/Sockets/">套接字</a></li><li><a class="toctext" href="../../stdlib/SparseArrays/">稀疏数组</a></li><li><a class="toctext" href="../../stdlib/Statistics/">统计</a></li><li><a class="toctext" href="../../stdlib/Test/">单元测试</a></li><li><a class="toctext" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">反射 与 自我检查</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Julia 运行时的初始化</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia 的 AST</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Julia 代码的 eval</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia 函数</a></li><li><a class="toctext" href="../../devdocs/cartesian/">笛卡尔</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">子数组</a></li><li><a class="toctext" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">边界检查</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../../devdocs/inference/">类型推导</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">报告和分析崩溃（段错误）</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb 调试提示</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>手册</li><li><a href>嵌入 Julia</a></li></ul><a class="edit-page" href="https://www.transifex.com/juliacn/manual-zh_cn/translate/#zh_CN/embeddingmd"><span class="fa"></span> 完善 Transifex 上的翻译</a></nav><hr/><div id="topbar"><span>嵌入 Julia</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="嵌入-Julia-1" href="#嵌入-Julia-1">嵌入 Julia</a></h1><p>正如我们在 <a href="../calling-c-and-fortran-code/#调用-C-和-Fortran-代码-1">调用 C 和 Fortran 代码</a> 中看到的, Julia 有着简单高效的方法来调用 C 编写的函数。但有时恰恰相反，我们需要在 C 中调用 Julia 的函数。这可以将 Julia 代码集成到一个更大的 C/C++ 项目而无需在 C/C++ 中重写所有内容。Julia 有一个 C API 来实现这一目标。几乎所有编程语言都能以某种方式来调用 C 语言的函数，因此 Julia 的 C API 也就能够进行更多语言的桥接。(例如在 Python 或是 C# 中调用 Julia ).</p><h2><a class="nav-anchor" id="高级别嵌入-1" href="#高级别嵌入-1">高级别嵌入</a></h2><p><strong>Note</strong>: This section covers embedding Julia code in C on Unix-like operating systems. For doing this on Windows, please see the section following this.</p><p>我们从一个简单的 C 程序开始初始化 Julia 并调用一些 Julia 代码：</p><pre><code class="language-c">#include &lt;julia.h&gt;
JULIA_DEFINE_FAST_TLS() // only define this once, in an executable (not in a shared library) if you want fast code.

int main(int argc, char *argv[])
{
    /* required: setup the Julia context */
    jl_init();

    /* run Julia commands */
    jl_eval_string(&quot;print(sqrt(2.0))&quot;);

    /* strongly recommended: notify Julia that the
         program is about to terminate. this allows
         Julia time to cleanup pending write requests
         and run all finalizers
    */
    jl_atexit_hook(0);
    return 0;
}</code></pre><p>为构建这个程序，你必须将 Julia 头文件的路径放入 include 路径并链接 <code>libjulia</code> 。例如 Julia 被安装到 <code>$JULIA_DIR</code>，则可以用 <code>gcc</code> 来编译上面的测试程序 <code>test.c</code>：</p><pre><code class="language-none">gcc -o test -fPIC -I$JULIA_DIR/include/julia -L$JULIA_DIR/lib test.c -ljulia $JULIA_DIR/lib/julia/libstdc++.so.6</code></pre><p>然后如果将环境变量 <code>JULIA_BINDIR</code> 设置为 <code>$JULIA_DIR/bin</code>，那么输出的程序<code>test</code>将会被执行。</p><p>或者查看 Julia 源代码目录 <code>test/embedding/</code> 文件夹下的 <code>embedding.c</code> 文件。 文件 <code>ui/repl.c</code> 则是另一个简单示例，用于设置链接 <code>libjulia</code> 时 <code>jl_options</code> 的选项 。</p><p>在调用任何其他 Julia C 函数之前第一件必须要做的事是初始化 Julia，通过调用 <code>jl_init</code> 尝试自动确定 Julia 的安装位置来实现。如果需要自定义位置或指定要加载的系统映像，请改用 <code>jl_init_with_image</code>。</p><p>测试程序中的第二个语句通过调用 <code>jl_eval_string</code> 来执行 Julia 语句。</p><p>在程序结束之前，强烈建议调用 <code>jl_atexit_hook</code>。上面的示例程序在 <code>main</code> 返回之前进行了调用。</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>现在，动态链接 <code>libjulia</code> 的共享库需要传递选项 <code>RTLD_GLOBAL</code> 。比如在 Python 中像这样调用：</p><pre><code class="language-none">&gt;&gt;&gt; julia=CDLL(&#39;./libjulia.dylib&#39;,RTLD_GLOBAL)
&gt;&gt;&gt; julia.jl_init.argtypes = []
&gt;&gt;&gt; julia.jl_init()
250593296</code></pre></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>如果 Julia 程序需要访问 主可执行文件 中的符号，那么除了下面描述的由 <code>julia-config.jl</code> 生成的标记之外，可能还需要在 Linux 上的编译时添加 <code>-Wl,--export-dynamic</code> 链接器标志。编译共享库时则不必要。</p></div></div><h3><a class="nav-anchor" id="使用-julia-config-自动确定构建参数-1" href="#使用-julia-config-自动确定构建参数-1">使用 julia-config 自动确定构建参数</a></h3><p><code>julia-config.jl</code> 创建脚本是为了帮助确定使用嵌入的 Julia 程序所需的构建参数。此脚本使用由其调用的特定 Julia 分发的构建参数和系统配置来导出嵌入程序的必要编译器标志以与该分发交互。此脚本位于 Julia 的 share 目录中。</p><h4><a class="nav-anchor" id="例子-1" href="#例子-1">例子</a></h4><pre><code class="language-c">#include &lt;julia.h&gt;

int main(int argc, char *argv[])
{
    jl_init();
    (void)jl_eval_string(&quot;println(sqrt(2.0))&quot;);
    jl_atexit_hook(0);
    return 0;
}</code></pre><h4><a class="nav-anchor" id="在命令行中-1" href="#在命令行中-1">在命令行中</a></h4><p>命令行脚本简单用法：假设 <code>julia-config.jl</code> 位于 <code>/usr/local/julia/share/julia</code>，它可以直接在命令行上调用，并采用 3 个标志的任意组合：</p><pre><code class="language-none">/usr/local/julia/share/julia/julia-config.jl
Usage: julia-config [--cflags|--ldflags|--ldlibs]</code></pre><p>如果上面的示例源代码保存为文件 <code>embed_example.c</code>，则以下命令将其编译为 Linux 和 Windows 上运行的程序（MSYS2 环境），或者如果在 OS/X 上，则用 <code>clang</code> 替换 <code>gcc</code>。：</p><pre><code class="language-none">/usr/local/julia/share/julia/julia-config.jl --cflags --ldflags --ldlibs | xargs gcc embed_example.c</code></pre><h4><a class="nav-anchor" id="在-Makefiles-中使用-1" href="#在-Makefiles-中使用-1">在 Makefiles 中使用</a></h4><p>但通常来说，嵌入的项目会比上面更复杂，因此一般会提供 makefile 支持。由于使用了 <strong>shell</strong> 宏扩展，我们就假设用 GNU make 。 另外，尽管很多时候 <code>julia-config.jl</code> 会在目录 <code>/usr/local</code> 中出现多次，不过也未必如此，但 Julia 也定位 <code>julia-config.jl</code>，并且可以使用 makefile 来利用它。上面的示例程序使用 Makefile 来扩展。：</p><pre><code class="language-makefiles">JL_SHARE = $(shell julia -e &#39;print(joinpath(Sys.BINDIR, Base.DATAROOTDIR, &quot;julia&quot;))&#39;)
CFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)
CXXFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)
LDFLAGS += $(shell $(JL_SHARE)/julia-config.jl --ldflags)
LDLIBS += $(shell $(JL_SHARE)/julia-config.jl --ldlibs)

all: embed_example</code></pre><p>现在构建的命令就只需要简简单单的<code>make</code>了。</p><h2><a class="nav-anchor" id="High-Level-Embedding-on-Windows-with-Visual-Studio-1" href="#High-Level-Embedding-on-Windows-with-Visual-Studio-1">High-Level Embedding on Windows with Visual Studio</a></h2><p>If the <code>JULIA_DIR</code> environment variable hasn&#39;t been setup, add it using the System panel before starting Visual Studio. The <code>bin</code> folder under JULIA_DIR should be on the system PATH.</p><p>We start by opening Visual Studio and creating a new Console Application project. To the &#39;stdafx.h&#39; header file, add the following lines at the end:</p><pre><code class="language-c">#define JULIA_ENABLE_THREADING
#include &lt;julia.h&gt;</code></pre><p>Then, replace the main() function in the project with this code:</p><pre><code class="language-c">int main(int argc, char *argv[])
{
    /* required: setup the Julia context */
    jl_init();

    /* run Julia commands */
    jl_eval_string(&quot;print(sqrt(2.0))&quot;);

    /* strongly recommended: notify Julia that the
         program is about to terminate. this allows
         Julia time to cleanup pending write requests
         and run all finalizers
    */
    jl_atexit_hook(0);
    return 0;
}</code></pre><p>The next step is to set up the project to find the Julia include files and the libraries. It&#39;s important to know whether the Julia installation is 32- or 64-bits. Remove any platform configuration that doesn&#39;t correspond to the Julia installation before proceeding.</p><p>Using the project Properties dialog, go to <code>C/C++</code> | <code>General</code> and add <code>$(JULIA_DIR)\include\julia\</code> to the Additional Include Directories property. Then, go to the <code>Linker</code> | <code>General</code> section and add <code>$(JULIA_DIR)\lib</code> to the Additional Library Directories property. Finally, under <code>Linker</code> | <code>Input</code>, add <code>libjulia.dll.a;libopenlibm.dll.a;</code> to the list of libraries.</p><p>At this point, the project should build and run.</p><h2><a class="nav-anchor" id="转换类型-1" href="#转换类型-1">转换类型</a></h2><p>真正的应用程序不仅仅要执行表达式，还要返回表达式的值给宿主程序。<code>jl_eval_string</code> 返回 一个 <code>jl_value_t*</code>，它是指向堆分配的 Julia 对象的指针。存储像 <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a> 这些简单数据类型叫做 <code>装箱</code>，然后提取存储的基础类型数据叫 <code>拆箱</code>。我们改进的示例程序在 Julia 中计算 2 的平方根，并在 C 中读取回结果，如下所示：</p><pre><code class="language-c">jl_value_t *ret = jl_eval_string(&quot;sqrt(2.0)&quot;);

if (jl_typeis(ret, jl_float64_type)) {
    double ret_unboxed = jl_unbox_float64(ret);
    printf(&quot;sqrt(2.0) in C: %e \n&quot;, ret_unboxed);
}
else {
    printf(&quot;ERROR: unexpected return type from sqrt(::Float64)\n&quot;);
}</code></pre><p>为了检查 <code>ret</code> 是否为特定的 Julia 类型，我们可以使用 <code>jl_isa</code>，<code>jl_typeis</code> 或 <code>jl_is_...</code> 函数。通过输入 <code>typeof(sqrt(2.0))</code>到 Julia shell，我们可以看到返回类型是 <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a>（在C中是 <code>double</code> 类型）。要将装箱的 Julia 值转换为 C 的double，上面的代码片段使用了 <code>jl_unbox_float64</code>函数。</p><p>相应的, 用 <code>jl_box_...</code> 函数是另一种转换的方式。</p><pre><code class="language-c">jl_value_t *a = jl_box_float64(3.0);
jl_value_t *b = jl_box_float32(3.0f);
jl_value_t *c = jl_box_int32(3);</code></pre><p>正如我们将在下面看到的那样，装箱需要在调用 Julia 函数时使用特定参数。</p><h2><a class="nav-anchor" id="调用-Julia-函数-1" href="#调用-Julia-函数-1">调用 Julia 函数</a></h2><p>虽然 <code>jl_eval_string</code> 允许 C 获取 Julia 表达式的结果，但它不允许将在 C 中计算的参数传递给 Julia。因此需要使用 <code>jl_call</code> 来直接调用Julia函数：</p><pre><code class="language-c">jl_function_t *func = jl_get_function(jl_base_module, &quot;sqrt&quot;);
jl_value_t *argument = jl_box_float64(2.0);
jl_value_t *ret = jl_call1(func, argument);</code></pre><p>在第一步中，通过调用 <code>jl_get_function</code> 检索出 Julia 函数 <code>sqrt</code> 的句柄(handle)。 传递给 <code>jl_get_function</code> 的第一个参数是 指向 定义<code>sqrt</code>所在的 <code>Base</code> 模块 的指针。 然后，double 值通过 <code>jl_box_float64</code> 被装箱。 最后，使用 <code>jl_call1</code> 调用该函数。也有 <code>jl_call0</code>，<code>jl_call2</code>和<code>jl_call3</code> 函数，方便地处理不同数量的参数。 要传递更多参数，使用 <code>jl_call</code>：</p><pre><code class="language-c">jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs)</code></pre><p>它的第二个参数 <code>args</code> 是 <code>jl_value_t*</code> 类型的数组，<code>nargs</code> 是参数的个数 </p><h2><a class="nav-anchor" id="内存管理-1" href="#内存管理-1">内存管理</a></h2><p>正如我们所见，Julia 对象在 C 中表示为指针。这就出现了 谁来负责释放这些对象的问题。</p><p>通常，Julia 对象由垃圾收集器（GC）释放，但 GC 不会自动就懂我们正C中保留对Julia值的引用。这意味着 GC 会在你的掌控之外释放对象，从而使指针无效。</p><p>GC 只会在 Julia 对象分配后运行。像 <code>jl_box_float64</code> 这种函数调用会触发内存分配，且有可能会发生在Julia代码运行过程中的任何时期。 但是在两次 <code>jl_...</code> 调用之间使用指针通常是安全的。但是为了确保值可以在 <code>jl_...</code> 调用中存活，我们必须告诉 Julia 我们保留对 Julia 值的引用。可以使用 <code>JL_GC_PUSH</code> 宏来完成：</p><pre><code class="language-c">jl_value_t *ret = jl_eval_string(&quot;sqrt(2.0)&quot;);
JL_GC_PUSH1(&amp;ret);
// Do something with ret
JL_GC_POP();</code></pre><p>调用 <code>JL_GC_POP</code> 释放先前 <code>JL_GC_PUSH</code> 建立的引用。 请注意 <code>JL_GC_PUSH</code> 正在堆栈上运行，所以在销毁堆栈之前它必须与之前的 <code>JL_GC_POP</code> 完全配对。</p><p>使用 <code>JL_GC_PUSH2</code>，<code>JL_GC_PUSH3</code> 和 <code>JL_GC_PUSH4</code> 宏可以一次 push 多个Julia 值。 要推送一个 Julia值的数组，可以使用 <code>JL_GC_PUSHARGS</code> 宏，它的用法如下：</p><pre><code class="language-c">jl_value_t **args;
JL_GC_PUSHARGS(args, 2); // args can now hold 2 `jl_value_t*` objects
args[0] = some_value;
args[1] = some_other_value;
// Do something with args (e.g. call jl_... functions)
JL_GC_POP();</code></pre><p>垃圾收集器也假设在这种情况下工作。即它知道每个老一代对象都指向年轻一代对象。 每次更新指针时，都必须使用 <code>jl_gc_wb</code> (write barrier，写屏障) 函数将指针通知给收集器，如下所示：</p><pre><code class="language-c">jl_value_t *parent = some_old_value, *child = some_young_value;
((some_specific_type*)parent)-&gt;field = child;
jl_gc_wb(parent, child);</code></pre><p>通常情况下不可能在运行时预测 值是否是旧的，因此 写屏障 必须被插入在所有显式存储之后。一个需要注意的例外是如果 <code>parent</code> 对象刚分配，垃圾收集之后并不执行。请记住大多数 <code>jl_...</code> 函数有时候都会执行垃圾收集。</p><p>直接更新数据时，对于指针数组来说 写屏障 也是必需的 例如：</p><pre><code class="language-c">jl_array_t *some_array = ...; // e.g. a Vector{Any}
void **data = (void**)jl_array_data(some_array);
jl_value_t *some_value = ...;
data[0] = some_value;
jl_gc_wb(some_array, some_value);</code></pre><h3><a class="nav-anchor" id="控制垃圾收集器-1" href="#控制垃圾收集器-1">控制垃圾收集器</a></h3><p>有一些函数能够控制GC。在正常使用情况下这些不是必要的。</p><table><tr><th style="text-align: left">函数</th><th style="text-align: left">描述</th></tr><tr><td style="text-align: left"><code>jl_gc_collect()</code></td><td style="text-align: left">强制执行 GC</td></tr><tr><td style="text-align: left"><code>jl_gc_enable(0)</code></td><td style="text-align: left">禁用 GC， 返回前一个状态作为 int 类型</td></tr><tr><td style="text-align: left"><code>jl_gc_enable(1)</code></td><td style="text-align: left">启用 GC， 返回前一个状态作为 int 类型</td></tr><tr><td style="text-align: left"><code>jl_gc_is_enabled()</code></td><td style="text-align: left">返回当前状态作为 int 类型</td></tr></table><h2><a class="nav-anchor" id="使用数组-1" href="#使用数组-1">使用数组</a></h2><p>Julia 和 C 可以不通过复制而共享数组数据。下面一个例子将展示它是如何工作的。</p><p>Julia数组用数据类型 <code>jl_array_t *</code> 表示。基本上，<code>jl_array_t</code> 是一个包含以下内容的结构：</p><ul><li>关于数据类型的信息</li><li>指向数据块的指针</li><li>关于数组长度的信息</li></ul><p>为了让事情比较简单，我们从一维数组开始，创建一个存有 10 个 FLoat64 类型的数组如下所示：</p><pre><code class="language-c">jl_value_t* array_type = jl_apply_array_type((jl_value_t*)jl_float64_type, 1);
jl_array_t* x          = jl_alloc_array_1d(array_type, 10);</code></pre><p>或者，如果您已经分配了数组，则可以生成一个简易的包装器来包裹其数据：</p><pre><code class="language-c">double *existingArray = (double*)malloc(sizeof(double)*10);
jl_array_t *x = jl_ptr_to_array_1d(array_type, existingArray, 10, 0);</code></pre><p>最后一个参数是一个布尔值，表示 Julia 是否应该获取数据的所有权。 如果这个参数 不为零，当数组不再被引用时，GC 会在数据的指针上调用 <code>free</code> 。</p><p>为了访问 x 的数据，我们可以使用 <code>jl_array_data</code>：</p><pre><code class="language-c">double *xData = (double*)jl_array_data(x);</code></pre><p>现在我们可以填充这个数组：</p><pre><code class="language-c">for(size_t i=0; i&lt;jl_array_len(x); i++)
    xData[i] = i;</code></pre><p>现在让我们调用一个对 <code>x</code> 就地操作的 Julia 函数：</p><pre><code class="language-c">jl_function_t *func = jl_get_function(jl_base_module, &quot;reverse!&quot;);
jl_call1(func, (jl_value_t*)x);</code></pre><p>通过打印数组，可以验证 <code>x</code> 的元素现在是否已被逆置 (reversed)。</p><h3><a class="nav-anchor" id="获取返回的数组-1" href="#获取返回的数组-1">获取返回的数组</a></h3><p>如果 Julia 函数返回一个数组，<code>jl_eval_string</code> 和 <code>jl_call</code> 的返回值可以被强制转换为<code>jl_array_t *</code>：</p><pre><code class="language-c">jl_function_t *func  = jl_get_function(jl_base_module, &quot;reverse&quot;);
jl_array_t *y = (jl_array_t*)jl_call1(func, (jl_value_t*)x);</code></pre><p>现在使用 <code>jl_array_data</code> 可以像前面一样访问 <code>y</code> 的内容。一如既往地，一定要在使用数组的时候确保 持有使用数组的引用。</p><h3><a class="nav-anchor" id="多维数组-1" href="#多维数组-1">多维数组</a></h3><p>Julia的多维数组以 列序优先 存储在内存中。这是一些 创建一个2D数组并访问其属性 的代码：</p><pre><code class="language-c">// Create 2D array of float64 type
jl_value_t *array_type = jl_apply_array_type(jl_float64_type, 2);
jl_array_t *x  = jl_alloc_array_2d(array_type, 10, 5);

// Get array pointer
double *p = (double*)jl_array_data(x);
// Get number of dimensions
int ndims = jl_array_ndims(x);
// Get the size of the i-th dim
size_t size0 = jl_array_dim(x,0);
size_t size1 = jl_array_dim(x,1);

// Fill array with data
for(size_t i=0; i&lt;size1; i++)
    for(size_t j=0; j&lt;size0; j++)
        p[j + size0*i] = i + j;</code></pre><p>请注意，虽然 Julia 的数组使用基于 1 的索引，但C API 中使用基于 0 的索引（例如 在调用<code>jl_array_dim</code>）以便用C代码的习惯来阅读。</p><h2><a class="nav-anchor" id="异常-1" href="#异常-1">异常</a></h2><p>Julia 代码可以抛出异常。比如：</p><pre><code class="language-c">jl_eval_string(&quot;this_function_does_not_exist()&quot;);</code></pre><p>这个调用似乎什么都没做。但可以检查异常是否抛出：</p><pre><code class="language-c">if (jl_exception_occurred())
    printf(&quot;%s \n&quot;, jl_typeof_str(jl_exception_occurred()));</code></pre><p>如果您使用 支持异常的语言的 Julia C API（例如Python，C＃，C ++），使用 检查是否有异常的函数 将每个调用 包装到 <code>libjulia</code> 中是有意义的，然后异常在宿主语言中重新抛出。</p><h3><a class="nav-anchor" id="抛出-Julia-异常-1" href="#抛出-Julia-异常-1">抛出 Julia 异常</a></h3><p>在编写 Julia 可调用函数时，可能需要验证参数 并抛出异常表示错误。 典型的类型检查像这样：</p><pre><code class="language-c">if (!jl_typeis(val, jl_float64_type)) {
    jl_type_error(function_name, (jl_value_t*)jl_float64_type, val);
}</code></pre><p>可以使用以下函数 引发一般异常：</p><pre><code class="language-c">void jl_error(const char *str);
void jl_errorf(const char *fmt, ...);</code></pre><p><code>jl_error</code>采用 C 字符串，而 <code>jl_errorf</code> 像 <code>printf</code> 一样调用:</p><pre><code class="language-c">jl_errorf(&quot;argument x = %d is too large&quot;, x);</code></pre><p>在这个例子中假定 <code>x</code> 是一个 int 值。</p><footer><hr/><a class="previous" href="../environment-variables/"><span class="direction">上一篇</span><span class="title">环境变量</span></a><a class="next" href="../code-loading/"><span class="direction">下一篇</span><span class="title">代码加载</span></a></footer></article></body></html>
